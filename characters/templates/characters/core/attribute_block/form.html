{% load dots %}
<div class="row">
    <h2 class="col-sm {{ object.get_heading }}">Attributes</h2>
</div>
<div class="row">
    <div class="col-sm">
        Prioritize primary, secondary, and tertiary Attribute categories and add {{ primary }}/{{ secondary }}/{{ tertiary }} dots
        <div id="total-remaining" style="font-weight: 600; color: var(--theme-text-secondary); margin-top: 8px;"></div>
    </div>
</div>
<div class="row">
    <div class="col-sm">
        <h3 class="{{ object.get_heading }}">Physical</h3>
        <div id="physical-status" style="font-weight: 600; font-size: 0.9rem; color: var(--theme-text-secondary);"></div>
    </div>
    <div class="col-sm">
        <h3 class="{{ object.get_heading }}">Social</h3>
        <div id="social-status" style="font-weight: 600; font-size: 0.9rem; color: var(--theme-text-secondary);"></div>
    </div>
    <div class="col-sm">
        <h3 class="{{ object.get_heading }}">Mental</h3>
        <div id="mental-status" style="font-weight: 600; font-size: 0.9rem; color: var(--theme-text-secondary);"></div>
    </div>
</div>
<div class="row">
    <div class="col-sm">Strength</div>
    <div class="col-sm dots">{{ form.strength }}</div>
    <div class="col-sm">Charisma</div>
    <div class="col-sm dots">{{ form.charisma }}</div>
    <div class="col-sm">Perception</div>
    <div class="col-sm dots">{{ form.perception }}</div>
</div>
<div class="row">
    <div class="col-sm">Dexterity</div>
    <div class="col-sm dots">{{ form.dexterity }}</div>
    <div class="col-sm">Manipulation</div>
    <div class="col-sm dots">{{ form.manipulation }}</div>
    <div class="col-sm">Intelligence</div>
    <div class="col-sm dots">{{ form.intelligence }}</div>
</div>
<div class="row">
    <div class="col-sm">Stamina</div>
    <div class="col-sm dots">{{ form.stamina }}</div>
    <div class="col-sm">Appearance</div>
    <div class="col-sm dots">{{ form.appearance }}</div>
    <div class="col-sm">Wits</div>
    <div class="col-sm dots">{{ form.wits }}</div>
</div>

<script>
(function() {
    'use strict';

    const PRIMARY = {{ primary }};
    const SECONDARY = {{ secondary }};
    const TERTIARY = {{ tertiary }};
    const BASE = 3; // Each category starts with 3 points (1 per attribute)
    const MAX_ATTRIBUTE = 5;
    const MIN_ATTRIBUTE = 1;
    const TOTAL_POINTS = BASE * 3 + PRIMARY + SECONDARY + TERTIARY; // 3+3+3 + 7+5+3 = 24

    // Target totals for each category - order doesn't matter, any category can be any target
    const TARGETS = [BASE + TERTIARY, BASE + SECONDARY, BASE + PRIMARY]; // [6, 8, 10]

    // Attribute groupings
    const CATEGORIES = {
        physical: ['strength', 'dexterity', 'stamina'],
        social: ['charisma', 'manipulation', 'appearance'],
        mental: ['perception', 'intelligence', 'wits']
    };

    // Find the submit button and hide it by default (will be shown when valid distribution achieved)
    const submitButton = document.querySelector('button[type="submit"]');
    if (submitButton) {
        submitButton.style.display = 'none';
        submitButton.disabled = true;
    }

    // Get all attribute input fields
    const inputs = {};
    Object.values(CATEGORIES).flat().forEach(attr => {
        const input = document.querySelector(`#id_${attr}`);
        if (input) {
            inputs[attr] = input;
            // Listen for changes on all inputs
            input.addEventListener('change', updateDisplay);
            input.addEventListener('input', updateDisplay);
        }
    });

    function getCategoryTotal(categoryName) {
        return CATEGORIES[categoryName].reduce((sum, attr) => {
            const value = parseInt(inputs[attr]?.value) || MIN_ATTRIBUTE;
            return sum + value;
        }, 0);
    }

    function getCurrentTotals() {
        return {
            physical: getCategoryTotal('physical'),
            social: getCategoryTotal('social'),
            mental: getCategoryTotal('mental')
        };
    }

    function getTotalPoints() {
        const totals = getCurrentTotals();
        return totals.physical + totals.social + totals.mental;
    }

    // Check if a given distribution can still reach a valid [6,8,10] assignment
    function isValidState(physTotal, socTotal, menTotal) {
        // Try all 6 permutations of assigning TARGETS to the three categories
        const permutations = [
            [physTotal, socTotal, menTotal],
        ];

        // Check if the current totals can fit into any permutation of TARGETS
        // Each category total must be <= some target, and we must be able to assign targets 1-to-1
        const currentTotals = [physTotal, socTotal, menTotal];

        // Generate all permutations of TARGETS
        const targetPermutations = [
            [TARGETS[0], TARGETS[1], TARGETS[2]],
            [TARGETS[0], TARGETS[2], TARGETS[1]],
            [TARGETS[1], TARGETS[0], TARGETS[2]],
            [TARGETS[1], TARGETS[2], TARGETS[0]],
            [TARGETS[2], TARGETS[0], TARGETS[1]],
            [TARGETS[2], TARGETS[1], TARGETS[0]],
        ];

        // Check if any permutation works
        for (const targetPerm of targetPermutations) {
            if (currentTotals[0] <= targetPerm[0] &&
                currentTotals[1] <= targetPerm[1] &&
                currentTotals[2] <= targetPerm[2]) {
                // This permutation could work
                return true;
            }
        }

        return false;
    }

    function isAttributeValueValid(attrName, targetValue) {
        // Can't exceed maximum or go below minimum
        if (targetValue > MAX_ATTRIBUTE || targetValue < MIN_ATTRIBUTE) {
            return false;
        }

        // Calculate what the totals would be with this attribute at targetValue
        const totals = getCurrentTotals();

        // Find which category this attribute belongs to
        let category = null;
        for (const [cat, attrs] of Object.entries(CATEGORIES)) {
            if (attrs.includes(attrName)) {
                category = cat;
                break;
            }
        }

        if (!category) return false;

        // Get current value of this attribute
        const currentValue = parseInt(inputs[attrName]?.value) || MIN_ATTRIBUTE;

        // Adjust the category total to reflect the new value
        totals[category] = totals[category] - currentValue + targetValue;

        // Check if the new state is still valid
        return isValidState(totals.physical, totals.social, totals.mental);
    }

    function canIncreaseAttribute(attrName) {
        const currentValue = parseInt(inputs[attrName]?.value) || MIN_ATTRIBUTE;
        return isAttributeValueValid(attrName, currentValue + 1);
    }

    // Find the maximum value this category can reach while maintaining validity
    function getMaxCategoryValue(categoryName) {
        const totals = getCurrentTotals();
        const currentValue = totals[categoryName];

        // Try increasing until we hit the limit
        for (let testValue = currentValue + 1; testValue <= TARGETS[TARGETS.length - 1]; testValue++) {
            const testTotals = { ...totals };
            testTotals[categoryName] = testValue;

            if (!isValidState(testTotals.physical, testTotals.social, testTotals.mental)) {
                return testValue - 1;
            }
        }

        return TARGETS[TARGETS.length - 1]; // Maximum possible
    }

    function updateDisplay() {
        const totals = getCurrentTotals();
        const totalPoints = getTotalPoints();
        const pointsRemaining = TOTAL_POINTS - totalPoints;

        // Check if we have a valid distribution
        const sortedTotals = [totals.physical, totals.social, totals.mental].sort((a,b) => a-b);
        const isValidDistribution = pointsRemaining === 0 &&
                                   JSON.stringify(sortedTotals) === JSON.stringify(TARGETS);

        // Control submit button visibility
        if (submitButton) {
            if (isValidDistribution) {
                submitButton.style.display = '';
                submitButton.disabled = false;
            } else {
                submitButton.style.display = 'none';
                submitButton.disabled = true;
            }
        }

        // Update total remaining points
        const totalElement = document.getElementById('total-remaining');
        if (totalElement) {
            if (pointsRemaining > 0) {
                totalElement.textContent = `${pointsRemaining} point${pointsRemaining !== 1 ? 's' : ''} remaining to allocate`;
                totalElement.style.color = 'var(--theme-text-secondary)';
            } else if (pointsRemaining === 0) {
                // Check if it's a valid distribution
                if (isValidState(totals.physical, totals.social, totals.mental)) {
                    if (isValidDistribution) {
                        totalElement.textContent = 'Complete! Valid distribution achieved.';
                        totalElement.style.color = '#28a745';
                    } else {
                        totalElement.textContent = 'All points allocated - verify distribution is correct';
                        totalElement.style.color = '#ffc107';
                    }
                } else {
                    totalElement.textContent = 'All points allocated - but distribution is invalid';
                    totalElement.style.color = '#dc3545';
                }
            } else {
                totalElement.textContent = `${Math.abs(pointsRemaining)} point${Math.abs(pointsRemaining) !== 1 ? 's' : ''} over limit!`;
                totalElement.style.color = '#dc3545';
            }
        }

        // Update per-category status
        for (const [categoryName, currentTotal] of Object.entries(totals)) {
            const element = document.getElementById(`${categoryName}-status`);
            if (element) {
                const maxValue = getMaxCategoryValue(categoryName);
                const canAdd = maxValue - currentTotal;

                if (canAdd > 0) {
                    element.textContent = `Total: ${currentTotal} (can add ${canAdd} more)`;
                    element.style.color = 'var(--theme-text-secondary)';
                } else {
                    element.textContent = `Total: ${currentTotal} (at maximum for valid distribution)`;
                    element.style.color = '#17a2b8';
                }
            }
        }

        // Validate each input and enforce constraints
        Object.entries(inputs).forEach(([attrName, input]) => {
            if (!input) return;

            const currentValue = parseInt(input.value) || MIN_ATTRIBUTE;

            if (input.tagName === 'SELECT') {
                // Handle select dropdowns
                Array.from(input.options).forEach(option => {
                    const optionValue = parseInt(option.value);
                    // Check if this specific value would be valid
                    const isValid = isAttributeValueValid(attrName, optionValue);
                    option.disabled = !isValid;
                });
            } else if (input.tagName === 'INPUT' && input.type === 'number') {
                // Handle number inputs - set max attribute dynamically
                input.min = MIN_ATTRIBUTE;

                // Find the maximum valid value for this attribute
                let maxAllowed = currentValue;
                for (let testValue = currentValue + 1; testValue <= MAX_ATTRIBUTE; testValue++) {
                    if (isAttributeValueValid(attrName, testValue)) {
                        maxAllowed = testValue;
                    } else {
                        break;
                    }
                }

                input.max = maxAllowed;
            }
        });
    }

    // Initial update on page load
    updateDisplay();
})();
</script>
